\chapter{FOSS projects as Cohesive Small Worlds}

As discussed in chapter \ref{collaborative_communities}, we named ``collaborative small world'' the network model that we propose in order to theoretically understand the structural dimension oc cooperation of FOSS projects. We argued that the family of networks that fit in the intersection of small world networks and structural cohesion networks exhibit consistent topological patterns. These patterns, we argue, provide the scaffolding for the emergence of collaborative communities. On the one hand, the generation of trust and congruent values among heterogeneous individuals are fostered by structurally cohesive groups in the network that play a key role in amplifying the effects of social interactions trough relatively long paths. On the other hand, the existence of highly connected local clusters linked together by relativelly small paths ---compared to suitable random networks--- allows successful collaboration among heterogeneous individuals with common interests even though they geographically dispersed and might never meet face to face.

This chapter focus on the empirical analysis of the network structure of two mature and well stablished FOSS projects: the CPython reference implementation of the Python programming language and the Debian Operating System. These two projects, as outlined in the previous chapter, are quite different despite being both successful FOSS projects. The Debian project has approximately ten times more participants than Python. Debian, being a complete Operating system, has many parts which are only lightly related between them becuse it contains programs that do very different tasks (eg the developers working on packaging software for music editing do not need to pay close attention to what devian developers focused on packaging word processors do). On the other hand, the Python programming language is a much more integrated software projects, and thus developers working on different parts of the language implementation have to play attention, and work very closely, with other developers.

This has a strong impact in the structure of the patterns of relations that emerge between developers in the two projects. The analysis presented here has two parts: first we will compute the small world metrics for the two projects, as described in chapter \ref{collaborative_communities}, and then we will compute the structural cohesion metrics as described in the chapter \ref{structural_cohesion}. However first we have to define how we build the networks for this two projects as a formalizations of the patterns of cooperation between the individuals in these projects.

\section{Modeling patterns of cooperation as networks}

Our modeling strategy to capture the patterns of relations among developers in these two projects is to focus on the actual contributions of each developer to the project. We model the cooperation patterns between individuals as affiliation networks \citep[chapter 8]{wasserman:1994}. This kind of networks contain two types of nodes: $N$ actors each of which belongs to one or more groups $M$. Such networks are bipartite or 2-mode because they contain two types of nodes and there are no edges between nodes of same type.

The two sets of nodes in the networks analyzed here are, on the one hand, human developers and, on the other hand, entities that conform the product that is released by the FOSS project. In the case of Debian, these entities are software packages, and in the case of Python, they are source code files. Note that the collaboration network is based on individual contribution but it not only captures the total amount of contribution that a given individual does, but also to which part of the project the contributions are focused, and who else in the project is also working on the same entities. This is why we name these bipartite graphs collaboration or cooperation networks.

One feature of most large software projects is modularity, that could be defined as the division of a software project into semi-independent parts, designed to work together but that can be developed relatively independently. In the case of an operating system, such as the Debian project, modularity is more important than in other software projects, such as Python. An operating system comprises a comprehensive set of software packages with varying importance, from those responsible for interacting with the hardware to others that provide certain features that are only useful in very specific and specialized configurations. On the other hand, an implementation of a programming language, such as Python, is also modular but their parts are much more closely related and have to be tightly integrated in order to function as a coherent whole.

This modeling approach captures mostly the informal patterns of relations that individuals establish when contributing to the project. FOSS projects have a wide range of formal organizational forms, and in this respect, they can be quite different. The definition of the leadership position in the two projects in which we focus this thesis nicely capture these differences in formal organization: Debian has a very developed formal bureaucracy, the project elects its leader each year through a secret vote of all its members after a electoral campaign where the candidates discuss among them and try to gain supports; Python instead has its original author ---Guido van Rossum--- in a permanent position of leadership, the people in the project refer to him, and his position of leadership, as ``Benevolent Dictator For Life'' (BDFL).

Despite these differences in the formal organization, if we focus on the patterns of relations among developers in the productive process, what we call the cooperation network, we can analyze the contribution dynamics, analyze hierarchical positions defined by these patterns, assess the pace of renewal in these positions, and determine the impact in the median active life on a developer in a project of being in a concrete hierarchical position.

For the case of the Debian project, we define that each package of source code is a module of the system or, in terms of network affiliation, a group or team. The main data source is the Ultimate Debian Database (UDD)\footnote{\href{http://udd.debian.org/}{http://udd.debian.org/} [accessed November 2016]} \citep{udd:2010}. The UDD contains information related to the work of each individual in the project which allow us to build the developers-packages affiliation network. One developer is linked to every package she has uploaded in the archive in a period of one year. Therefore, the result is a 2-mode network with developers ---the actors--- and packages ---the groups--- as the two types of nodes.

For the case of the Python project, we define that each source code file that forms the reference implementation of the programming language is a module of the system or, in terms of network affiliation, a group or team. Thus, contributions are lines of source code added or deleted from one of the source code files of Python's code base. The main data source is the Python source code repository \footnote{\href{https://hg.python.org/}{https://hg.python.org/} [accessed November 2016]}, which is under version control. That means that each change to any source code file is recorded and attributed to a person.

These collaboration relations are only part of the whole patterns of cooperative relations established among developers in both projects. We cannot obtain more accurate data of the frequent interactions between developers related to the production process that take place in a large variety of on-line or face-to-face settings. However, the subset of collaboration relations captured by our approach are significative and serve our purpose to analyze the global patterns of relations among direct producers because the result of the productive process is, in fact, the archive of packages that form the Debian operating system or the set of source code files taht form the implementation of the Python programming language. Therefore, we base our analysis of cooperation on the registered contribution of each developer to the final product of the productive process delivered to end users.

Moreover, two important advantages of this approach are, on the one hand, that we have data on all uploads ---in the case of Debian--- or all the modifications of source code files ---for the Python project---, thus we do not need to worry about sample bias because we have accurate data of all the work performed in the period under analysis. On the other hand, we have a strict definition of what cooperation means, which allow us analyze the evolution of collaboration patterns throughout the history of the two projects. Therefore, we can make meaningful comparisons between years in the same project, and between projects.

\subsection{Null models}

Both kinds of analysis presented in this chapter have in common the use of null models. In empirical analysis of networks we need to be able to compare the statistical measures obtained of our actual networks with a null model in order to assert that what we observe is not the result of pure chance. That is, we have to make sure that the metrics observed in the actual networks are significantly different to the patterns of relations that we might expect if the relation between developers and packages, or developers and files in the case of Python, were produced uniformly at random.

To this end, the canonical approach is to compare the measures of actual networks with measures taken from random networks that maintain some constraints of the original network, such as the degree distribution. \citet*{newman:2003,nsw:2001} provided a configuration model in order to generate random graphs with arbitrary degree distributions. In the analysis presented here we have used the configuration model for 2-mode networks to generate 100 random null models for each year. The configuration model assigns at random developers to packages, or developers to source code files, maintaining the concrete skewed distribution of packages by developer and files by developer observed in the actual networks.

\section{Small World Metrics}

As we discussed in chapter \ref{collaborative_communities}, a network fits the small world model if it is more clustered ($CC$) than its random network counterpart but has approximately the same average distance ($L$) between nodes. In unipartite or 1-mode networks, $CC$ is the mean probability that two nodes that are neighbors of the same other node will themselves be neighbors. Thus, this measure is computed as the ratio of triangles ---a fully connected graph of 3 nodes--- over two-stars ---three nodes connected by two edges---. But, in bipartite or 2-mode networks there can be no triangles because, by definition, edges can only link nodes of different type. Following \citet{robins:2004}, \citet{lind:2005} and \citet{latapy:2008}, local cohesion in 2-mode networks can be measured with the notion of cluster coefficient based on squares ($CC_4$). $CC_4$ is the ratio between the number of squares ($C_4$) ---composed by two nodes of each type linked by four edges--- over the number of three-paths ($L_3$) ---composed by two nodes of each type linked by three edges--- (See appendix \ref{sw-affnets} for a formal definition of $CC_4$). Like $CC$, $CC_4$ applied to bipartite networks is a measurement of local cohesion.

The Small World Index ($Q$) is a summary indicator of the smallworldiness of a network and accounts for both the relation of the clustering coefficients of actual networks compared to their random counterparts, and the relation of average path length (a global measure of the average distance between nodes in a network) of actual networks compared to their random counterparts. Networks with the Small World Index ($Q$) bigger than 1 are considered small world networks (see appendix \ref{sw-affnets} for details). We compute the Small World Index using the following formulas:

\begin{equation}
% \begin{split}
Q = \frac{CC_{ratio}}{L_{ratio}}
% \end{split}
\end{equation}

Where:

\begin{align}
CC_{ratio}& = \frac{CC_{actual}}{CC_{random}} &
L_{ratio}& = \frac{L_{actual}}{L_{random}} \nonumber \\
\end{align}


In the first place we compute small world metrics for Debian networks. The results are shown in table \ref{swi_debian}.

\input{tables/table_small_world_debian_years.tex}

As we can see, the Debian project cooperation networks for all years analyzed are indeed small world networks. Their Small World Index ($Q$) is way bigger than 1, ranging from 21 in 2011 to 80 in year 2000. This large value of $Q$ is driven by the fact that the clustering coefficient ---the measure of local cohesion--- of the observed networks is approximately a hundred times higher than in their random counterparts. However the average distance between nodes in the actual networks is slightly higher than the distance in their random counterparts, which reduces the value of the small world index. Therefore we can conclude that Debian cooperation networks fit nicely the small world model. 

For the Python project, the results for the small world metrics are presented in table \ref{swi_python}.

\input{tables/table_small_world_python_years.tex}



\section{Structural Cohesion Metrics}

\input{tables/table_structural_cohesion_python_years.tex}

\begin{figure}[p]
%\centering
\subfloat[Actual Python network 2000]{
\label{fig:s3d_actual_python_2000}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2000}
}
\hspace{.01in}
\subfloat[Null model Python network 2000]{
\label{fig:s3d_null_python_2000}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2000_null}
}

\subfloat[Actual Python network 2004]{
\label{fig:s3d_actual_python_2004}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2004}
}
\hspace{.01in}
\subfloat[Null model Python network 2004]{
\label{fig:s3d_null_python_2004}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2004_null}
}

\subfloat[Actual Python network 2013]{
\label{fig:s3d_actual_python_2013}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2013}
}
\hspace{.01in}
\subfloat[Null model Python network 2013]{
\label{fig:s3d_null_python_2013}
\includegraphics[scale=0.23]{figures/3d_scatter_python_2013_null}
}

\caption[Python average connectivity three-dimensional scatter plots.]{Python average connectivity three-dimensional scatter plots for actual networks and their random null models counterparts. X and Y are the positions determined by the Kamada-Kawai layout algorithm. The vertical dimension is average connectivity. Each mark is a node of the network as two-mode networks they contain both programs (triangles) and developers (circles).}
\label{fig:python-s3d}
\end{figure}


\input{tables/table_structural_cohesion_debian_years.tex}


\begin{figure}[p]
%\centering
\subfloat[Actual Debian network 2000]{
\label{fig:s3d_actual_debian_2000}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2000}
}
\hspace{.01in}
\subfloat[Null model Debian network 2000]{
\label{fig:s3d_null_debian_2000}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2000_null}
}

\subfloat[Actual Debian network 2004]{
\label{fig:s3d_actual_debian_2004}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2004}
}
\hspace{.01in}
\subfloat[Null model Debian network 2004]{
\label{fig:s3d_null_debian_2004}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2004_null}
}

\subfloat[Actual Debian network 2011]{
\label{fig:s3d_actual_debian_2011}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2011}
}
\hspace{.01in}
\subfloat[Null model Debian network 2011]{
\label{fig:s3d_null_debian_2011}
\includegraphics[scale=0.23]{figures/3d_scatter_debian_2011_null}
}

\caption[Debian average connectivity three-dimensional scatter plots.]{Debian average connectivity three-dimensional scatter plots for actual networks and their random null models counterparts. X and Y are the positions determined by the Kamada-Kawai layout algorithm. The vertical dimension is average connectivity. Each mark is a node of the network as two-mode networks they contain both programs (triangles) and developers (circles).}
\label{fig:debian-s3d}
\end{figure}

