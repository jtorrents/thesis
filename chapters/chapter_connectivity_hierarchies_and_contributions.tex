\chapter{Connectivity Hierarchy and Individual Contributions}
\label{contributions}

\section{Cooperation networks' connectivity hierarchies as open elites}

The analysis of the hierarchical structure of organizations has been a central topic on organizational research in the last decades. This analysis has been mainly static in the sense that the focus of interest has been, among others, the distinctions between formal hierarchies and informal patterns of relations \citep{krackhardt:1993, mcfarland:2001}, the comparative analysis of the shape of the hierarchy \citep{blau:1962,blau:1964}, the impact of different kinds of hierarchical structures in the outcomes of the organizations' activities, the potential contradictions among the internal hierarchical structure of organization and its goals towards a more egalitarian society \citep{michels:1915,selznick:1949}, to cite only a few key issues.

Despite the huge amount of work devoted to the analysis of hierarchy in organizations, the dynamic dimension of the hierarchy has received a lot less attention. The work on the dynamic dimension has focused on the evolution of hierarchical structures of organizations through time \citep{blau:1969}. There is however another possible definition of dynamic dimension in the analysis of hierarchy in organizations: the ratio of renewal of the individuals in the positions defined by that hierarchy. This important element of the dynamic dimension of hierarchy has been partially approached from the perspective of vacancy chains \citep{white:1970,stewman:1983}. However this approach has focused mostly on the career paths of individuals inside organizations instead of focusing on the pace of renewal of individuals in the hierarchical structure of organizations.

My approach to analyze the structure and impact on individual contributions of connectivity hierarchies in cooperation networks follows the concept of open elite, first suggested by John Padgett in his statistical analysis of marriage patterns, family structure and elite reproduction in Florence between 1282 and 1494 \citep{padgett:2010}. In this work, Padgett suggests that despite a tendency to maintain an elite structure through marriages, the existence of three contending dimension of status ---age of lineage, wealth and, political faction--- led higher-status families to reach out and marry middle-tier ones, thus contributing unintentionally to social mobility. This approach leads to a ``reconceptualization of the concept of elite, more as a fluidly reproduced ideal than as a stable demographic reality'' \citep[360]{padgett:2010}. 

This reconceptualization was further developed in a study of the emergence of commercial biotechnology in the United States, where \citet{powell:2005} identified an ``open elite'' network structure among dedicated biotech firms, pharmaceutical companies, venture capitalists, government agencies and universities which ``allowed for extensive crosstalk among a diverse set of organizations, melding practices and resources from multiple sources. Precisely because these organizations did not follow a common set of evaluative criteria, its heterogeneous, multiple affiliations made responsiveness to challenges possible.'' \citet[467]{powell:2005}.

I propose that hierarchical structures can be classified in a continuum, the two extreme points of which are, on the one hand, a static hierarchy ---where when an individual is appointed in a position of the hierarchy, this position is for life--- and, on the other hand, a dynamic hierarchy ---where the individuals occupying positions defined by the hierarchy have a very high pace of renewal. Notice that, in this context, the hierarchy can refer to both the formal and informal patterns of relations. An example of static hierarchy is the catholic church, where an appointment ---even far from the top level--- will typically last for life. On the other hand, dynamic hierarchies are a lot less common, especially before the last years of the twentieth century.

Since then we have witnessed the emergence of new organizational forms, mainly around Free and Open Source Software projects (FOSS). I propose that one of the central characteristics of these new organizational forms is precisely their high ratio of turnover in key hierarchical positions, both in the formal and informal internal organization. I do think that this dynamic dimension has not been taken into account in the analysis of those new organizational forms, and only by considering and analyzing it we can deepen our understanding, not only of the new emerging organizational forms, but also further our understanding of organizations and the challenges that they face.

In this chapter, I will start from this reconceptualization of an open elite in a dynamic hierarchy, and suggest that in FOSS projects there is a structural elite, identified as subgroups in the connectivity structure of their cooperation network that guarantee continuity and cohesion, but that these positions experience high membership turnover, and thus that this elite can be characterized as an open elite.

\subsection{The dynamism of hierarchies in FOSS cooperation networks}

Free and Open Source Software (FOSS) communities have attracted a lot of attention from researchers of different fields since the late nineties of the past century. The first academic accounts of this phenomenon were mainly descriptive; their main focus was to just describe the organization of FOSS communities, the individual motivations of the people that form these communities, and the quality of the products that they produced \citep{benkler:2014}. Most of the interest was derived from the fact that FOSS communities do not conform to the accounts of collective dynamics and individual motivations established by the dominant neoclassical economic theories.

Academic efforts took mainly two directions. On the one hand, some authors tried to reconcile the dynamics of FOSS communities with neoclassical economic accounts. This effort was mainly focused on the individual motivations of the participants in those communities. They tried to explain these motivations in terms of rational self-interested individuals, as prescribed by dominant economic theories. On the other hand, other authors saw the emergence of FOSS communities as a new organizational form that provided a more democratic way of enabling collective production without the constrains imposed by the markets and/or bureaucratic organizational forms \citep{benkler:2002, benkler:2006, castells:2013}.

The later accounts of FOSS communities were initially uncritically celebratory of the phenomenon. They were heavily influenced by practitioners and advocates of the FOSS phenomenon which emphasized the technical superiority of the products developed by FOSS communities, while maintaining an ethical stand that valued more cooperation and reciprocity than competition and self-interest. One of the most influential early accounts from practitioners was \citet{raymond:1999} that proposed, among other things, that the technical superiority of FOSS software products was due to the ``Linus law'', which states that ``given enough eyeballs, all bugs are shallow'', suggesting that given a large enough developer and user community with access to the source code, all software errors (ie ``bugs'') will be detected quickly and the solution will be obvious at least to someone.

Thus ``Linus law'' suggests that FOSS communities are composed by a large set of individuals loosely organized with a very flat or nonexistent hierarchy among them, and that all individuals might contribute more or less the same: a pair of eyes that should look at the source code in order to improve it. This somewhat naive account of the dynamics of FOSS production process was accepted uncritically by many academics that were sympathetic with the arguments of the FOSS practitioners. Some critical voices, coming mostly from Computer Science, challenged this claim with sound empirical arguments; for instance \citet{glass:2002} correctly noted that if ``Linus Law'' was right then the number of bugs found in a software project should increase linearly with the number of people looking at their source code. No such thing have been proved empirically. Also, ``Linus Law'' not only treats each pair of eyes (ie individuals) as equally important, it also implicitly assumes that all bugs are similar, which is very implausible.

Other early empirical research, coming mostly from Computer Science, has pointed out that even in big, mature and widely used FOSS projects, only few of the participants account for the lion's share of the work done. For instance, \citet{mockus:2002} show that less that 20 developers of the Apache project\footnote{Apache is one of the most successful FOSS projects, it's flagship product is the Apache web server which powers more than 50\% of the web sites that form the WWW.} contributed more than 80\% of the code base. This core of developers is embedded in a larger set of participants, that mainly help reporting and fixing errors, answering questions about the software in public forums, and writing documentation. Later empirical research has confirmed that the distribution of contributions in FOSS projects is right-skewed and heavy tailed, meaning that most participants make very small contributions, and only few individuals make almost all relevant contributions.

Recent empirical research on peer production projects (concretely user edited wikis) has also shown that these projects exhibit deep contribution inequalities \citep{shaw:2014}. The authors suggest that these projects may conform to \citet{michels:1915} ``iron law of oligarchy'' which states that organizations tend towards oligarchy as they grow, even if democracy and participation are part of the core goals of the organization. Therefore, there is ample empirical evidence that confirms that there is an important differentiation of roles and functions among participants on FOSS communities. This fact does not fit well with the picture of a flat hierarchy of peers portrayed by early accounts of the phenomenon.

I do think that the narrative of a flat hierarchy of peers was so successful because the formal organization of most FOSS projects is usually quite fuzzy, and very different of the formal structure of other kinds of organizations. However, the informal structure emerging from the patterns of cooperation among individuals in a FOSS project is quite hierarchical because reflects the fact that only few individuals are responsible for most contributions to the project. I propose that the way to advance our theoretical understanding of the FOSS phenomenon is by analyzing their social structure. The social structure of a community are the patterns of relations established among individual participants in the process of building the software packages (or any other product, such as on on-line encyclopedia) that they release. The public nature of FOSS communities implies that most of the data generated in the production process is available, and thus an important source of empirical data that we can use to test competing theoretical accounts of the phenomenon. 

In this chapter I show that the developers that contribute the most to the projects analyzed are in the higher levels of the connectivity structure of the project's cooperation networks. Moreover, by analyzing the composition of individuals on these key topological positions I'm able to assess to which extend there is turn over of individuals at the top of the connectivity structure. My analysis shows that the ratio of renewal of individuals at this structural position is quite fast, which characterizes FOSS communities as dynamic hierarchies and open elites. Thus, if we analyze cross-sectionally (ie in a concrete point of time) a FOSS project, a very small fraction of the participants are the ones that actually do the lion's share of contributions, as previous empirical research has shown. However if we analyze the evolution of contributions longitudinally, we find that the persons that contribute the most change through time. This continuous renewal of the people that does most of the work ---what I call dynamic hierarchy--- is a key mechanism to explain how FOSS projects, which are mostly voluntary based, geographically distributed, and mostly operated from the Internet, can thrive and evolve to a point where they are key pieces of the infrastructure that enables the Internet and other essential Information technologies.

The focus on the rotation of individuals at the top levels of the connectivity structure brings us to the issue of the robustness of the FOSS communities. From a pure network perspective, it is usual to analyze robustness by removing nodes and measuring how this affects the size of the giant connected component in the network \citep{albert:2000}. Nodes are removed following different mechanisms; either at random ---to simulate failure--- or removing nodes according to their degree ---to simulate a deliberate attack. However these mechanisms are best suited for analyzing the robustness of physical networks, such as the Internet. They clearly fall short for analyzing the robustness of FOSS communities, because not random failures nor targeted attacks are the main mechanisms through which the persons that work on FOSS communities turn over.

My approach here is to analyze the median active life of developers in a FOSS project as a better way of assessing the robustness of a FOSS community. I also apply the well established survival analysis techniques \citep{miller:2011} in order to describe and model the flux of people throughout the history of a FOSS community.  I found that the position of an individual in the connectivity structure of the collaboration network also impacts significantly in the median active life of a developer in the project.

\section{Methods}

In this chapter I analyze the role of the connectivity structure of the cooperation networks in shaping individual contributions to Debian and Python projects. I focus on the structural positions in which the most active contributors are, and the median active life of individual contributions on the project. My main empirical interest is about the volume of contribution of each individual to the project, and the role of contributions ---as independent variable--- in relevant elements of a FOSS project, such as the median active life of individual contributors to the project.

My modeling strategy to capture the patterns of relations among developers in these two projects is to focus on the actual contributions of each developer to the project. Following the approach in the previous chapter, I model cooperation networks as bipartite graphs, where the two sets of nodes are, on the one hand, human developers and, on the other hand, entities that conform the product that is released by the FOSS project. In the case of Debian, these entities are software packages, and in the case of Python, they are source code files. Note that the cooperation network is based on individual contribution but it not only captures the total amount of contribution that a given individual does, but also to which part of the project the contributions are focused, and who else in the project is also working on the same entities. This is why I name these bipartite graphs cooperation networks.

This modeling approach captures mostly the informal patterns of relations that individuals establish when contributing to the project. FOSS projects have a wide range of formal organizational forms, and in this respect, they can be quite different. The definition of the leadership position in the two projects in which I focus this thesis nicely capture these differences in formal organization: Debian has a very developed formal bureaucracy, the project elects its leader each year through a secret vote of all its members after a electoral campaign where the candidates discuss among them and try to gain supports; Python instead has its original author ---Guido van Rossum--- in a permanent position of leadership, the people in the project refer to him, and his position of leadership, as ``Benevolent Dictator For Life'' (BDFL). Decisions in the Python project are usually made by consensus, but when consensus in not reached after collective deliberation, the leader of the project makes the decision. 

Despite these differences in the formal organization, if we focus on the patterns of relations among developers in the productive process, what I call the cooperation network, we can analyze the contribution dynamics, analyze hierarchical positions defined by these patterns, assess the pace of renewal in these positions, and determine the impact in the median active life of a developer of being in a concrete hierarchical position.

One of the challenges that I faced, that is both theoretical and methodological, is how to define cohesive groups in cooperation networks. There are many ways of defining a cohesive group given a cooperation network. My aim was to define groups in cooperation networks in a way that is theoretically sound from a sociological point of view. Network science is nowadays quite interdisciplinary, and a lot of physicist have recently proposed a bunch of techniques, under the label of community detection algorithms \citep{fortunato:2010}, that determine groups in networks based on the patterns of relations among the entities of the network.

However, these techniques are suboptimal from a sociological theory point of view because the four key elements that a sociologically sound group classification should have are not present in most, if not all, most used community detection algorithms, as discussed in chapter \ref{structural_cohesion} (and published at \citep{torrents:2015}). The four key dimensions are: robustness (the groups should not depend on only one or few individuals to be a group), overlap (persons usually are part of more than one cohesive group), positional dimension (some actors, because of their position in the global patterns of relations, obtain preferential access to information or resources that flow through the network), and hierarchy (cooperation networks have \emph{hierarchical structure} in the sense that highly cohesive subgroups are nested inside less cohesive ones).

As discussed in previous chapters, I model cooperation networks using the proposed Cohesive Small World model, which is partially based on the structural cohesion model, developed by White, Moody and Harary \citep{white:2001, moody:2003}. This model is based on the graph theoretic measure of node connectivity, and defines cohesive groups as $k$-components, that is, groups of nodes in which $k$ nodes have to be removed in order to disconnect the group. $K$-components form the connectivity structure of the network, and aptly capture the central elements of a sociological definition of cohesive group \citep{torrents:2015} as discussed at length in chapter \ref{structural_cohesion}.

However, there are some important practical difficulties related to the computation of the measures that characterize the structural cohesion model. Their time complexity is super quadratic, approximately of the order of the forth power of the size of the input network. This makes non practical the exact computation of the $k$-component structure in networks bigger than several hundreds of nodes. I use here some useful heuristics that allow to approximately compute the connectivity structure of large sparse networks in a reasonable time frame, as I have shown in chapter \ref{structural_cohesion}.

Once I built the cooperation networks for the two projects, and determined their connectivity structure, I perform a descriptive analysis of the percentage of total contributions by connectivity level. This simple descriptive analysis shows that there is a strong correlation between the position of a developer in the connectivity structure of the cooperation network and her total amount of contribution to the project.

I then deepen the analysis by modeling individual contributions to the project using different regression models in order to asses the relation of the structural positions that individuals occupy with their level of contribution to the project. For the case of the Debian project, contributions are uploads of packages to the central repository of the project, thus contributions in this context have to be modeled as a discrete variable. For this case I used a negative binomial regression model to deal with the over-dispersed count data from the values of the discrete contributions variable.

For the case of the Python project, contributions are lines of source code added or deleted from one of the source code files of Python's code base. I modeled contributions using a panel regression with individual fixed effects. This design allows us to account for unobserved variability among the individual developers, such as cultural background or coding expertise, and disentangle if the position of a developer in the connectivity hierarchy has an effect in her level of contribution to the project.

Finally, I'm also interested in the impact of the position than an individual occupies in the cooperation network with her long term involvement with the project. To that end I applied Cox proportional-hazards regression for survival data to both Debian and Python projects. In its origin, survival analysis, was focused on modeling lifespans of individuals and is still widely used in medicine. However, this kind of analysis can also be used to model any kind of duration. I model the active life of a developer in a FOSS project as the period that this developer is doing at least one contribution. I consider a developer ``dead'' when she no longer contributes.

\section{Regression modeling and mobility analysis}

\subsection{Modeling individual contributions}

As discussed in the previous section, the empirical work on FOSS communities has already established that it is only a small fraction of all participants in a project who are responsible for most contributions. As a first step for the analysis, I analyze the topological position of the individuals that contribute the most in the patterns of relations ---the social structure--- among individuals in that project. Following the proposed cohesive small world model (see chapter \ref{collaborative_communities}), and one of its foundaments: the structural cohesion model \citep{moody:2003} (see chapter \ref{structural_cohesion}), I found that these individuals are part of the top connectivity levels of the cooperation network, that is, they are members of $k$-components of high $k$ which represent cohesive subgroups nested inside each other in the network that emerges from the patterns of relation among developers in the productive process. 

\begin{figure}[h]
%\centering
\subfloat[Evolution of the percentage of developers by connectivity level for the Debian project.]{
\label{fig:evo-sc}
\includegraphics[scale=0.29]{figures/evolution_developers_debian_years}
}
\hspace{.05in}
\subfloat[Evolution of the percentage of contributions by developers by connectivity levels for the Debian project.]{
\label{fig:evo-contrib}
\includegraphics[scale=0.29]{figures/evolution_connectivity_debian_years}
}

\caption[Debian: Evolution of connectivity levels and contributions.]{Evolution of the percentage of developers in each connectivity level (left) and evolution of the percentage of contributions by developers by connectivity levels (right) for the Debian project. The green surface represents the developers in the top connectivity levels, that is developers that are part of a $k$-component with $k$ greater or equal than 3. The orange surface represents developers in bicomponents, that is $k$-components with $k=2$.}
\label{fig:evo}
\end{figure}

Figure \ref{fig:evo-sc} displays the evolution of the percentage of developers by connectivity level in the period under analysis for the Debian project. The green surface represents the developers in the top connectivity levels, that is developers that are part of a $k$-component with $k$ greater or equal than 3. The orange surface represents developers in bicomponents, that is $k$-components with $k=2$. Note that all developers in the top connectivity levels are also part of the bicomponents. In the period under analysis, there is a significant increment of the hierarchy of connectivity levels, as I have shown in the previous chapter, which peaks in 2007 with 17\% of the developers in connectivity levels with $k \ge 3$. The percentage of developers in bicomponents, goes from 26\% in 2002 to 50\% in 2005 and peaks at almost 54\% of developers at 2006 and 2008. From 2005 to the end of the period under analysis the percentage stabilizes between 45\% and 54\%. The percentage of developers in higher connectivity levels also experiments an important increment, it goes from less than 1\% in 1999 and 2000 to 8\% in 2011, and peaks around 16\% in 2007.

Figure \ref{fig:evo-contrib} displays the percentage of contributions by developers by connectivity level. We can see that, although there are few developers in high connectivity levels, they are responsible for a big fraction of the total contribution in terms of packages uploaded to the Debian archive. For instance, in 2004 the developers in the top connectivity levels were less than 10\% of all developers, but they contributed 46\% of all uploads to the Debian repository that year. That same year, 45\% of the developers were embedded in a bicomponent and contributed 72\% of all uploads. In 2009, 12.5\% of the developers that were part of the top connectivity levels were responsible for 71\% of all contributions, while developers in $k$-components with $k \ge 2$ contributed 85\% of all uploads while being only 50\% of all developers that uploaded at least one package to the Debian archive that year. 

Therefore, it is clear that there is a strong correlation between the connectivity level of a developer and her contribution to the project. To further the analysis, I modeled the contributions ---which in this case are uploads of new versions of packages to the Debian archive--- using a negative binomial regression. Which is well suited for the count nature of the dependent variable (\# of uploads) and its over dispersion. I cannot use a zero inflated model in this case because by design there is no zeros in the dataset as I only considered developers that have at least uploaded one package. This regression model is not for all the period analyzed on the previous analysis (1999-2012) because the scale of the Debian system ---in terms of the number of packages--- has grown too much in this period and thus the later years would have been over-represented. I opted for analyzing the development time of a complete version of the Debian system. Concretely I analyzed the period from 2011-02-06 to 2013-05-04  corresponding to the development cycle of the Debian release 7.0 codename Wheezy.

I controlled the contributions of each developer, on the one hand, by several key variables related to the technical side of the production process, such as the size (\emph{log(Package size)}) and the dependencies of each package (\emph{\# of package dependencies}), the bugs reported for each package (\emph{\# of bugs reported}), or the time that the developer has been active in the project (\emph{Developer tenure (years)}). And, on the other hand, I also controlled for centrality measures including degree centrality (\emph{Degree centrality}) and closeness (\emph{Closeness}), and a local cohesion metric (\emph{Square Clustering}). As can be seen in table \ref{debian_nbinomial}, the connectivity level in which a developer is embedded (\emph{$k$-component number}) has a positive and significative impact on her contributions to the project.

\input{tables/table_debian_uploads_negative_binomial.tex}

Tables \ref{desc_table_nbinomial} and \ref{corr_table_nbinomial} on appendix \ref{support-tables} show the descriptive statistics and the correlation matrix of the variables used in this model. In terms of the importance of the variables in the model, the independent variable $k$-number (the value $k$ of the connectivity level in which the developer is embedded in the connectivity hierarchy) is the second most important only after degree centrality. I measure variable importance here as normalized magnitude by dividing the coefficient in the model by its standard deviation.
 
The fact that the quantification of contributions in the Debian project is a discrete variable ---number of package uploads to the Debian repository--- restricts the options of regression modeling available. The over dispersed negative binomial regression is clear in that the connectivity level in the cooperation network has a positive and significant impact on the level of contribution of each developer. However it does not allow to take into account unobserved individual differences among developers that might explain their level of contribution.

Another source of concern with this model it's the potential endogeneity of the relation between the dependent variable and the network metrics, which include the independent variable. Given that the cooperation network is build precisely based on uploads to the Debian archive, which is the dependent variable in this model. I will refine the analysis to deal with endogeneity problems using data from the Python project. 

As discussed above, the data from Python project allows us to measure contributions as lines of source code added by each developer. This variable can be safely considered continuous and therefore I can model it as a panel regression with individual and time fixed effects. This modeling approach, on one hand, solves the problem of unobserved differences between developers that might have an effect of the volume of their contributions, and on the other hand, also allows to account for changes in system through time that I was not able to model in the negative binomial regression of table \ref{debian_nbinomial}.
 
Let's first take a look at the descriptive data on percentage of contributions by the top connectivity level (the developers that are in the $k$-component with the highest $k$) in the Python project. Figure \ref{fig:composition} displays the evolution of percentage of developers that are at the top connectivity level throughout the history of Python project. The orange surface shows the percentage of developers that are included in the giant bicomponent, and the green surface represents the percentage of developers in the top connectivity level, that is the $k$-component of maximum $k$ in the cooperation network of that year.

We can see that around 40\% of the developers that have contributed some code are in the top level of the connectivity hierarchy, and this percentage is quite stable through time. Note that the actual $k$ value of the top level varies in time, depending on how the patterns of relations among developers and source code files have evolved each concrete year. The node connectivity of the $k$-component in the top of the connectivity hierarchy is almost all years between 7 and 10, with a minimum of 6 in 2005, as I have shown in the previous chapter.

\begin{figure}[h]
\centering
\subfloat[Evolution of the percentage of developers by connectivity level for the Python project.]{
\label{fig:composition}
\includegraphics[scale=0.29]{figures/evolution_developers_python_years}
}
\hspace{.01in}
\subfloat[Evolution of the percentage of contributions by developers by connectivity levels for the Python project.]{
\label{fig:contributions}
\includegraphics[scale=0.29]{figures/evolution_connectivity_python_years}
}
\label{fig:comp_and_contrib}
\caption[Python: Evolution of connectivity levels and contributions.]{Evolution of the percentage of developers by connectivity level (left) and evolution of the percentage of contributions by developers by connectivity levels (right) in the Python project. The green surface represents the developers in the top connectivity level, that is developers that are part of a $k$-component with maximum $k$. The orange surface represents developers in bicomponents, that is $k$-components with $k=2$.}
\end{figure}

Figure \ref{fig:contributions} shows the evolution of the contributions of the developers by connectivity level, measured in terms of lines of source code added to the project. Note that $k$-components are nested inside each other, like Russian dolls, thus the contributions of developers in the giant biconnected components also include the contributions of the developers in the top connectivity level. As we can see, developers in the giant biconnected component are the authors of almost all contributions, but they are also between 80\% and 97\% of all developers.

However developers in the top connectivity level are only between 40\% and 55\% of all developers on the project, but they are the authors, the latter years of the period under analysis, of around 90\% of the source code contributions. Some years their percentage of contributions is lower (a bit less than 60\%) but this is mostly before 2001, when the community was much smaller than in the following years, or in 2005. Therefore only a small fraction of the developers are responsible of the lion's share of the work done in the project. Note however that the contributions to source code files, what is measured here as contributions, does not include all the work done that is important to the project, such as managing the infrastructure for distributing Python, helping users in the mailing list, maintaining the websites of the project, etc ... 

For modeling individual contributions to the Python project, I used a panel regression with individual and year fixed effects. This design allows us to account for unobserved variability among the individual developers, such as cultural background or coding expertise, and disentangle if the position of a developer in the connectivity hierarchy has an effect in her level of contribution to the project. As we can see in the table, being in the top connectivity level has a positive and significant impact in the level of contribution of each developer. Note also that considering the $k$-number of the developer (ie, the level $k$ of the highest $k$-component in which the developer is embedded) adds explanation power on the model and suggest that the impact of the connectivity hierarchy on the productivity of developers operates at all connectivity levels, not only at the top.

The model also includes control variables for the centrality of each developer in the cooperation network (Degree centrality and Closeness), the number of direct collaborators of each developer (collaborators), the tenure of each developer (measured as the number of years since their first contribution) and the value of square clustering which is a measure of local cohesion. Tables \ref{desc_table_panel} and \ref{corr_table_panel} on appendix \ref{support-tables} show the descriptive statistics and the correlation matrix of the variables used in this model.

\input{tables/table_plm_contributions.tex}

This regression modeling of Python contributions by connectivity level complements and confirms the negative binomial regression results applied to the Debian project. The $k$-components of the cooperation network define groups of developers that are the core of the project and are responsible for most of the contributions, both in Debian and in Python project. These groups are central in a structural sense as they are at the top of the connectivity hierarchy that emerges from the patterns of cooperation among individual developers. The models presented thus far point out that these developers are also the ones responsible for the lion's share of the contributions, and thus the hierarchical structure of the cooperation network shapes the volume of contribution of individual developers.

However the fixed effects panel regression also has a potential problem of endogeneity as the cooperation network form which I computed the connectivity hierarchy is based on individual contributions and this was the dependent variable in both this regression model and the negative binomial model I explored before for the case of the Debian project. Note that despite this potential problem, if we look at the correlation tables for these models at appendix \ref{support-tables}, we can see that the correlations between the independent and dependent variables is not high enough ---0.488 for the negative binomial and 0.211 for the fixed effects panel regression--- to create collinearity problems in the models.

\input{tables/table_zinfl_peps.tex}

To deal with this potential endogeneity problem I now use a new dependent variable that captures contributions to the Python project but that is not directly related with the number of lines of source code contributed by each developer. This new variables is the number of PEPs (Python Enhancement Proposals) approved. PEPs\footnote{\href{https://www.python.org/dev/peps/}{https://www.python.org/dev/peps/} accessed November 2016} are design documents providing information to the Python community, or describing a new feature for Python or its processes or environment. The PEP provide a concise technical specification of the feature and a rationale for the feature. PEPs are the primary mechanisms for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python. The PEP author is responsible for building consensus within the community and documenting dissenting opinions.

Thus, PEPs are a key mechanism of innovation and evolution of the Python project, and the developers that successfully propose a PEP are the ones designing the technical future of the Python project, and thus we can consider them to be in a leadership position. By using the number of accepted PEPs for each developer as a dependent variable in the regression modeling I sort out the endogeneity problem of the plain number of lines of source code added to the project. For modeling PEPs contributions I used a zero inflated negative binomial model for count data, as the number of PEPs each developer authored is a discrete variable. The fact that many developers did not author any PEP requires us to use the zero inflated version of the negative binomial model.

I tested the model assumptions and compared it with alternative models such as a Poisson model, a plain negative binomial, and Hurdle model and found that the zero inflated negative binomial model is the one that better fits the number of accepted PEPs as a dependent variable. A good way to test the fit of the model is to see the number of zero observations that each model predicts. Zero observations are developers that either have not proposed any PEP or the PEPs that they proposed have not been accepted for each year (thus actual observations are pairs developer -- year). The actual number of zeros in the Python PEP dataset is 449: the Poisson model predicts 322 zeros, the plain negative binomial predicts 434, and the zero inflated negative binomial model predicts 450 zeros, which is very close to the actual number of observed zeros.

Table \ref{python_zinfl} presents the results of the zero inflated negative binomial model. Tables \ref{desc_table_zinfl} and \ref{corr_table_zinfl} on appendix \ref{support-tables} show the descriptive statistics and the correlation matrix of the variables used in this model. This model shows that there is a positive and statistically significant effect of being part of the top connectivity level on the number of accepted PEPs authored by each developer. In this case however, if I include both being at the top to the connectivity hierarchy and the $k$-component number, only the former is significative. This model also shows that tenure in the project (the number of years since a developer made her first contribution to Python) has also a positive and statistically significant effect on the number of accepted PEPs authored. The tenure variable is the one that has a stronger impact on the dependent variable, but the second strongest is the variable that reflects if a developer is at the top of the connectivity hierarchy in the cooperation network. Note that I also included the individual developer contribution in terms of lines of source coded added as a control variable, which is not significative in this model. 

Given that PEPs are not source code contributions, there is no potential endogeneity in this model, and I can assert that the connectivity hierarchy that emerges from the patterns of relations established by developers while contributing to the project ---the cooperation network--- shapes the contribution dynamics of individuals in the project. Also PEPs define the evolution of the Python language, thus the people that write them are effectively leading its development and evolution. This demonstrates that cooperation has an important structural dimension which cannot be neglected if we want to understand the mechanisms that shape individual contributions to the project.

\subsection{Developer mobility in the connectivity hierarchy through time}

The next step is to determine if the developers on the top connectivity level are always the same people, or if there is rotation and turn over. Table \ref{python_mobility_table} shows, for each year under analysis, the number of developers in the top connectivity level of the cooperation network and the percentage that they represent of the total number of developers, the number of new developers that enter the top connectivity level and the percentage that they represent of the developers in the top connectivity level, the number of developers that get out of the top connectivity level and the percentage that they represent, and the number of developers that get back in the top connectivity level; that is, developers that have been in the top connectivity level other years than the previous year and they get back in it.

\input{tables/table_mobility_python.tex}

As we can see, there is a constant flow of developers in and out of the top connectivity level throughout the history of Python project, especially when the community is consolidated after year 2000. Some years, such as 2000, 2002, 2007, and 2009, more than 40\% of the developers on the top connectivity level are developers that have never been in that position before. If I also consider the developers that came back to the top connectivity level after being outside for more than one year as new developers, many other years see a significative renewal of the developers in the top position of the connectivity hierarchy.

The constant flow in and out of the top level of the connectivity hierarchy of the cooperation network is a key element to understand the dynamics of individual contributions to the project because even though a very big part of the contributions come from a small set of developers (the ones in the top connectivity level), these developers are not the same people throughout the history of the project. This fact sheds light over the findings of recent empirical analysis of contributions from collaborative communities \citep{shaw:2014}, where the authors find that only a small fraction of participants are the ones that contribute most of its contents, and they thus propose that some form of the ``iron law of oligarchy'' might be in play. They however do not analyze longitudinally if these people are the same throughout the history of the project. I suspect that they might not be the same people, and thus that a constant renewal of the people that contribute the most, such the one described here for the Python project, might also be in play in those projects.  

I argue that the constant flow in and out of the top level of the connectivity hierarchy of the cooperation network is what defines this hierarchy as an open elite, where the positions defined by it ---the connectivity subgroups in the cooperation network in this concrete analysis--- have a very high rate of turn over and renewal. Thus, in a community where most of their participants do not obtain their means of subsistence from the work that they do in the community, the rapid turn over of individuals that contribute the most is a key mechanism for ensuring the long term viability of the project beyond its original founders. Thus, this is a key mechanism that explains how large scale cooperation works, at least in FOSS projects.

A nice way to visualize the constant flow of developers to the top connectivity level is figure \ref{fig:sankey}, which shows a Sankey diagram where each piece of the diagram represents the number of developers in the top connectivity level for a given year; the arrows that come from the top represent the number of developers who in year $y - 1$ were not at the top connectivity level but are in the top level at year $y$, the arrows on the bottom represent the number of developers that are in the top connectivity level at year $y$ but not anymore in year $y + 1$. The horizontal arrow represents the number of developers that at year $y$ are in the top connectivity level, and continue to be there at year $y + 1$. Note that in this figure I do not draw the developers that came back to the top connectivity level after being part of it other years than the immediately previous years (these numbers are reported in table \ref{python_mobility_table}).

\begin{landscape}
\begin{figure}[p]
\begin{center}
\includegraphics[scale=0.42]{figures/sankey_mobility_python_years}
\caption[Sankey diagram of Python developer mobility in the top connectivity level.]{Sankey diagram of Python developer mobility in the top connectivity level. The numbers at the top are the number of new developers entering the top connectivity level, numbers inside are the number of developers at the top connectivity level, number below are the number of developers leaving the top connectivity level.}
\label{fig:sankey}
\end{center}
\end{figure}
\end{landscape}


\subsection{Modeling robustness as median active life of individuals in the project}

In the network literature, robustness of networks is usually measured with simulations of failures (removing nodes at random) and attacks (removing nodes incrementally starting for the ones with higher degree) \citep{albert:2000}. However this is not a good way to model the evolution of participation in a FOSS project.

I use here the survival analysis approach \citep{miller:2011}, that according to my knowledge, is the first time that is applied to model the turn over in FOSS communities. In its origin, survival analysis, was focused on modeling lifespans of individuals and is still widely used in medicine. However, this kind of analysis can also be used to model any kind of duration. Thus I model the active life of a developer in the Python project as the period that this developer is contributing at least one line of source code. I consider a developer ``dead'' when she no longer contributes to the project.

To estimate the survival function from the empirical data we used the Kaplan-Meier estimator \citep{kaplan:1958} defined as:

$$
\hat{S}(t) = \prod_{t_i < t} \frac{n_i - d_i}{n_i}
$$

where $d_i$ are the number of ``death events'' at time $t$ and $n_i$ is the number of subjects at risk of death at time $t$. If I compute the Kaplan-Meier estimator for all developers (figure \ref{fig:survival_all}) we can see that the median survival time of a developer on the community, defined as the point in time where on average half of the population has abandoned the community, is 6 years. But if I consider separately the developers in the top level of the connectivity hierarchy (figure \ref{fig:survival_groups}), their median survival time is 12 years; but only 3 years for the developers that are not on the top of the connectivity hierarchy.

Although it is clear that the two survival functions depicted in figure \ref{fig:survival_groups} are different, I performed the log rank test, a common statistical test in survival analysis that compares two event series' generators. The test confirms that that the two series have different generator mechanisms and are significantly different. The Kaplan-Meier estimator analysis and plots are performed using the lifelines python package \citep{lifelines:2016}.

Finally, given that we observe an important flow of new developers towards the top levels of the connectivity hierarchy; and also having established that the contributions of the developers in these top levels is significantly higher than other developers, it is interesting to analyze the personal trajectories of developers in the project. I model the active life of developers in the Python project using a Cox proportional hazards model with time-dependent covariates and right-censoring \citep[appendix on survival analysis]{fox:2002}.


\begin{figure}[H]
\centering
\subfloat[Survival Function for all developers]{
\label{fig:survival_all}
\includegraphics[scale=0.35]{figures/survival_all}
}
\hspace{.01in}
\subfloat[Survival Function for developers in the top connectivity level]{
\label{fig:survival_groups}
\includegraphics[scale=0.35]{figures/survival_top}
}
\label{fig:survival}
\caption[Survival function using the Kaplan-Meier estimate.]{Estimation of the survival function using the Kaplan-Meier estimate. The median survival time of a developer in the community, defined as the point in time where on average half of the population has abandoned the community, is 6 years if I consider all developers (left). But if I consider separately the developers in the top level of the connectivity hierarchy (right), their median survival time is 12 years; but only 3 years for the developers that are not on the top of the connectivity hierarchy.}
\end{figure}

I'm interested in assessing the impact of being in the higher levels of the connectivity structure in terms of the expected active life of a developer in the project. The covariates in the model are: the number of accepted PEPs authored by each developer, the contributions of each developer to the Python project, measured as number of source code lines, the number of collaborators (ie second order neighbors in network terms) that each developer has in the cooperation network, the degree centrality and closeness of each developer in the cooperation network, the highest $k$ of a $k$-component in which the developer is embedded, and the \emph{Top connectivity level} dummy variable that equals to 1 if the developer is in the $k$-component of highest $k$ in the cooperation network for that time period, and 0 otherwise.

\input{tables/table_survival.tex}

In order to fit the model, I divided the data in ``strata'' based on the value of ``tenure'' covariate which reflects the time a developer has been active in the project measured in years. Each stratum is permitted to have a different baseline hazard function, while the coefficients of the remaining covariates are assumed to be constant across strata. Stratification is most natural when a covariate takes on only a few distinct values, and when the effect of the stratifying variable is not of direct interest.

Finally the estimations of the variance and standard errors of the coefficients of the covariates of interest are robust, and clustered for each developer. This is necessary because in a proportional hazards model with time-dependent covariates, each individual has more than one row in the database. Concretely, each individual has a row for each period of one year in which he or she has been an active contributor to the source code of the Python project. Tables \ref{desc_table_survival} and \ref{corr_table_survival} on appendix \ref{support-tables} show the descriptive statistics and the correlation matrix of the variables used in this model.

As we can see in table \ref{python_cox_reg}, the effect of being part of the top connectivity level is significant and negative with a coefficient of -1.467, meaning that it decreases the yearly hazard of leaving the project by a factor of $e^b = e^{-1.467} = 0.23$, that is, 77\%. This interpretation holds assuming that all other covariates remain constant. The coefficient for $k$-number ---the highest $k$ of a $k$-component in which the developer is embedded--- is also significative and negative with a coefficient of -0.295, which means that an increment of one connectivity level decreases the yearly hazard of leaving the project by a factor of $e^b = e^{-0.295} = 0.74$, that is, 26\%.

It is relevant that both measures of cohesion are significative and negative when included in the same model, although the $k$-component number it's significative at $p < 0.01$ and being part of the top component at $p < 0.05$. When these two variables are included in the model none of the control variables is significative. I can conclude that not only being at the top connectivity level has a relevant impact on the active life of a developer in a project, but also smaller increments in cohesion of the groups in which a developer is embedded have a significant impact on their active life in the project.

\section{Summary}

In this chapter I explored the dynamic dimension of the connectivity hierarchies that emerge on the cooperation networks of the Python and Debian projects. I defined cooperation networks as the patterns of relations among developers established while contributing to the project. The dynamic analysis, in this case, is not only a longitudinal account of the changes in the hierarchy through time, but also the analysis of the pace of renewal of individuals in the positions defined by the hierarchy. I propose that organizations ---and not only FOSS projects--- can be classified in a continuum depending on the pace of renewal of the individuals that occupy top positions in the hierarchy.

I showed that the cohesive small world model (see chapter \ref{collaborative_communities}), which is partially grounded on the structural cohesion model \citep{white:2001, moody:2003} is a solid theoretical framework to define cohesive groups ---$k$-components--- in cooperation networks. The nested structure of $k$-components nicely captures the hierarchy in the patterns of relations that individual contributors establish when working together. This hierarchy, on the one hand, reflects the empirically well established fact that in FOSS projects only a small fraction of the developers account for most of the contributions. And, on the other hand, refutes the naive views of early academic accounts that characterized FOSS projects as a flat hierarchy of peers in which every individual does more or less the same.

I also showed that the position of individual developers in the connectivity hierarchy of the cooperation networks impacts significantly, on the one hand, on the volume of contributions that an individual does to the project. And, on the other hand, the median active life of developers in the project. I argue that the latter is a better way to analyze robustness of FOSS projects than the classical random and targeted attacks that has been used to asses robustness in other kinds of networks.

My main conclusion is that the connectivity structure of collaborative communities' cooperation networks can be characterized as a open elite, where the top levels of this hierarchy are filled with new individuals at a high pace. This feature is key for understanding the mechanisms and dynamics that make FOSS communities able to develop long term projects, with high individual turnover, and yet achieve high impact and coherent results. Thus, the renewal of individuals at the top levels of the connectivity hierarchy of cooperation networks is a key mechanism for enabling large scale cooperation. Therefore I can conclude that cooperation in FOSS communities has a structural dimension because membership in cohesive groups that emerge from the cooperation networks ---the repeated patterns of relations that the direct producers establish in the production process--- has an important and statistically significative impact on both the volume of individual contributions, and on the median active life of developers in the projects under analysis.
